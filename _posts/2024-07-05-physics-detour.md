---
title: Physics Detour
---

So I recall mentioning in mid-June that I was working on a separate project for a bit that shouldn't have taken too long. To be fair, the part I was referring to at the time took about as long as I expected it to, but towards the end, it seemed like something more elaborate would justify the effort. I'll demonstrate a bit of what this physics model was actually doing and what changes were made to elevate it beyond just translating from one language to another.

In early June, I took up the task of converting a Monte Carlo physics simulation of triangulated hyperbolic space, derived from an ancient C program and later Java applet incarnation, into something more useable within C# and the Unity editor. Yes, it's not very game related, and it wasn't really much of a technical challenge other than in deciphering the implementation of the physical rules in minimally-documented code. I honestly wasn't expecting this to help much with my game projects, so it was a pleasant surprise to pick up some tidbits about Editor scripting and C# along the way.

Originally, the working Java version I started with was designed for imagining a 2D projection of hyperbolic space wrapped around the surface of a sphere, where curvature is depicted by the packing of points and triangles along its surface. Points could be inserted or deleted and links between triangles flipped, in order to create random fluctuations. Using some parameters for controlling the temperature of the system and coupling between nodes, the simulation can be tweaked to achieve a fairly smooth surface as triangles appear, disappear and reform around different points. If that doesn't really mean much to you, it's fine, since it's mostly for the cool visuals. I've made the new version of this simulation's project files available [here](https://github.com/codelazarus14/dtsimulation-unity). Here's a couple screenshots of the difference, which is mostly just color:

![A screenshot of the original Java version's visualization, showing a black outline of a circle filled in with a radially-symmetric, branching nest of triangles that grow larger towards the center of the circle.](/../assets/images/blog/0011/dtjava.png)
![A screenshot of the first Unity version that uses thicker, white lines on a teal background, also depicting a circle filled with fluctuating triangles from boundary to center.](/../assets/images/blog/0011/dtunity.png)

After converting the code and its Java rendering dependencies into C# and Gizmos, respectively, I wanted to bring the simulation up a little bit more in quality than its predecessor. The original surface behind the projection was a sphere, and although the math for visualizing a sphere wasn't important to the original simulation as much as pinning points around a boundary in a fixed radius, I wanted to use the opportunity to visualize something a bit more interesting and apply my own rules to enforce curvature at equilibrium.

A short 2 weeks later, I've finished cleaning up the original code to migrate away from some of the C-style code that had been... *modified*... in the Java version (`int[1]` arguments , I see you).  I was happy to leverage the older style sometimes to learn the difference between the `ref` and `out` keywords in C#, since I've mostly just avoided them. In this case, since the simulation is constantly passing around a ton of data every frame to recompute the triangulation, node positions and face normals, it makes sense to re-use as many data structures as possible in the old style. 

The simulation is now 3D, and instead of trying to keep a stable, radially-symmetric 2D analog for curvature, it now actually starts with a list of purely random node positions and attempts to bring them into a more spherical equilibrium over time. There's also debugging tools in the editor for looking at the face normals, currently a WIP which I may not return to, average position of all nodes, changing the amount of random wobbles performed on vertices to help them move towards their equilibrium positions and so on. Like the original, it updates at a fixed timestep, in which all of the nodes are passed over to receive random fluctuations and a chance at performing a link-flip to lower the energy of the simulation. It's a little hard to visualize the progression over time in two screenshots, but the general idea is that it moves towards a more spherical configuration:

![A screenshot of the simulation at the start, with nodes scattered around a central point. Lines between the nodes are technically fixed by the configuration at startup, but in this case look equally zany because of the nodes' random positions.](/../assets/images/blog/0011/dtunity-before.png)

![A screenshot of the simulation after running for a little while, with nodes now arranged in a more regular-looking network of points in a potato-shape.](/../assets/images/blog/0011/dtunity-after.png)

The triangulation fluctuates based on the values of both the wobble and coupling parameters, so it never reaches a fixed, perfectly sphere-like shape without a lot more points and a lot of tweaking (and this was only after 5 minutes or so on a smaller configuration). More proof of its attempts at symmetry in 3D:

![A screenshot of the Unity scene view, looking at the simulation from outside the camera's projection. This angle also shows a potato-shaped network of points and lines, and with the Unity Transform gizmo revealing that the average position of all the nodes is fairly close to the center of the GameObject they started around.](/../assets/images/blog/0011/dtunity-after3d.png)

There's still more changes that could be made to this, but for the time being, I wanted to make sure it was in a better state when I left it, with more comments, readable variable names and less lingering 90s clutter. It should be possible for far-future descendants, or someone else down the road, to make sense of this code, assuming they still have access to computers. Thankfully, I think the physics rules guiding this demo won't have changed by then.

I'm dying to get back to my games work, hopefully by this weekend. We're in for a hot summer and I've just got an air conditioner for the first time in my life, which should make the work more pleasant in the coming days. Until next week!