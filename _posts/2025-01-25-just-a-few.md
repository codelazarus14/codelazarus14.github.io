---
title: Just A Few Bug Fixes
---

I admit that the title is deliberately ironic, but it hadn't dawned on me how much has changed since the last blog post until I started writing. Happy New Year! 

I've been falling behind on updates for a little while, since there's been some sparse periods between work on the current RTS game project. At the same time, a ton of changes to code structure and feature implementations have led to new "order groups" for managing units' tasks, movement vectors being calculated along the isometric plane rather than orthographically, and some new groundwork for improving on unit movement, formations and projectiles.

I'm not sure how much of this will be easy to show visually, but I'll start, in no particular order, from the new singletons for selecting and ordering units. A lot has changed in the way that responsibilities previously given to static bits of individual Components are now handled through external managers. Ever unit now has a Unit component attached for assigning unit data (attack range, move speed, health etc.) via ScriptableObjects, which improves organization and allows for unit stats to be modified independent of the code. The Unit class is not to be confused with the additional UnitComponent, a MonoBehaviour override which can be detected and initialized by the Unit component (confusing) on `Awake()`. This is mostly for my convenience as well as to avoid coupling components' functionality to unit data (ie: it should be possible to make the components work with manually-edited inputs as well as to feed them a UnitInfo). Exciting stuff.

Alongside having a more streamlined way for units' components to share references, a new SelectionManager and OrderManager now handle the responsibilities previously placed in Selectable and Orderable as static fields, respectively. The main reason for doing this was to enable components to access information about other component instances beyond themselves, while separating responsibilities for responding to events that affect all instances of a component (selection box being dragged over units) versus individuals (a unit arrives at its move destination). In addition, the new OrderManager facilitates queuing up orders for any number of units, provided they make up a unique set, and retrieving a unit's relationship to current order groups when necessary (looking up a unit's order group to delist it when its orders are overridden). Note the current waypoint (still using the cyan ovals, I know) is not shown, since I've been referencing AOE again.

![A screenshot of the game, showing multiple waypoints set between a unit group's current path and future path destinations.](/../assets/images/blog/0018/multiorder.png)

The most visibly notable change beyond the queued-up waypoints is to how unit movement is conducted. Previously, I had written a fairly simple update loop for setting the rigidbody's velocity to a direction rotated to face the unit's next pathing target, multiplied by the speed. While this is fine in most 2D games where the plane of motion would line up with the camera's perspective, I started to realize that this was making units travel faster in terms of tile distance when moving vertically on-screen. To fix this, and to futureproof some of the annoying effort of figuring out how to translate flat screen coordinates into the 3D space of the plane relative to the camera, I added a new IsoSpace singleton to the Grid/Tilemap object. Here I consolidated old methods for translating between world and tile spaces alongside new ones for mapping vectors in world space into the isometric plane. The discrete isometric tilemap is used to compute a set of basis vectors that define the continuous isometric plane, so that movement can now be performed according to how units should travel through their slanted world. Accordingly, units now move slower vertically than horizontally, while traveling the same number of tiles at a constant (isometric) speed. 

![A screenshot of the game, showing a set of basis vectors aligned with the X and Y axes of the isometric grid, and a third Z axis projecting upward from the plane.](/../assets/images/blog/0018/basisvectors.png)

I could go on about the changes to how attack radii in tiles are computed and checked against, a new InstanceList structure for keeping track of active components and my new habit of creating UML diagrams to figure out how to structure my code (how proper!), but I'll save it in the interest of producing more interesting things to blog about. Of course, I've learned by now that game development is very iterative and the final structure can be difficult to predict as needs change, and so on... but I also have some plans for making assets down the road that should give the game a little more flavor. Naturally as a programmer I've been hesitant to leave my comfort zone to spend some time learning how to make the art I want to create, but I'm definitely running out of excuses to delay it any longer. Hopefully I'll have something ready soon, but regardless of what I intend to do with this project in the near future, I have plans for another artistic venture beyond this project which might take up some of my more immediate time off (Source... 2?)